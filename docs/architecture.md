# アーキテクチャドキュメント

## 概要

「しのうたタイム」は、VTuber「幽音しの」さんの配信で歌唱された楽曲を検索・閲覧できる非公式ファンサイトです。本ドキュメントでは、リファクタリング後のアプリケーションのアーキテクチャ、システム構成、各コンポーネントの責務、および技術スタックについて説明します。

## リファクタリングの背景

リファクタリング前のコードベースは機能的には動作していましたが、以下の課題がありました：

- **コードの重複**: 各ページで似たようなデータ読み込み処理が繰り返されている
- **責務の分離不足**: Home.pyに多くのロジックが集中している（約500行）
- **テスト可能性の低さ**: ビジネスロジックがUIコードと密結合している
- **保守性の課題**: 長い関数、複雑なデータ処理ロジック

リファクタリングの目標は、コードの保守性、テスト可能性、拡張性を向上させることです。

## レイヤー構造

リファクタリング後のアプリケーションは、明確に分離された4つのレイヤーで構成されています。

```
┌─────────────────────────────────────────────────────────┐
│   プレゼンテーション層（UI）                              │
│   - Home.py（メインページ）                              │
│   - pages/*.py（サブページ）                             │
│   - src/ui/components.py（UIコンポーネント）             │
│   - footer.py（フッター）                                │
│   - style.css（スタイル）                                │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│   ビジネスロジック層                                      │
│   - src/services/data_service.py（データサービス）       │
│   - src/services/search_service.py（検索サービス）       │
│   - src/core/data_pipeline.py（データパイプライン）      │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│   ユーティリティ層                                        │
│   - src/core/utils.py（ユーティリティ関数）              │
│   - src/config/settings.py（設定管理）                   │
│   - src/config/logging_config.py（ロギング設定）         │
│   - src/exceptions/errors.py（カスタム例外）             │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│   データ層                                                │
│   - data/M_YT_LIVE.TSV（配信データ）                     │
│   - data/M_YT_LIVE_TIMESTAMP.TSV（楽曲データ）           │
│   - data/V_SONG_LIST.TSV（楽曲リスト）                   │
│   - data/tweet_embed_code.html（Twitter埋め込み）        │
│   - data/tweet_height.txt（Twitter高さ設定）             │
└─────────────────────────────────────────────────────────┘
```

### レイヤー間の依存関係

- **プレゼンテーション層** → ビジネスロジック層、ユーティリティ層
- **ビジネスロジック層** → ユーティリティ層、データ層
- **ユーティリティ層** → データ層（設定ファイルのみ）
- **データ層** → 依存なし

各レイヤーは上位レイヤーからのみ参照され、下位レイヤーが上位レイヤーを参照することはありません。これにより、保守性とテスト可能性が向上しています。

## コンポーネント詳細

### 1. プレゼンテーション層

ユーザーインターフェースを提供する層です。Streamlitフレームワークを使用して、Webページとして表示されます。

#### Home.py（メインページ）

**責務**: 
- アプリケーションのエントリーポイント
- 楽曲検索機能の提供
- 検索結果の表示と段階的表示
- ユーザー入力の受付

**主要機能**:
- DataPipelineを使用したデータ処理
- SearchServiceを使用したキーワード検索
- UIコンポーネントを使用した検索フォーム表示
- UIコンポーネントを使用した結果テーブル表示
- UIコンポーネントを使用したページネーション

**リファクタリングの成果**:
- 約500行から約200行に削減
- ビジネスロジックをサービスクラスに分離
- UIコンポーネントの再利用

#### pages/01_Information.py（情報ページ）

**責務**:
- 配信スケジュールの表示
- お知らせ情報の提供
- 外部コンテンツの埋め込み

**主要機能**:
- UIコンポーネントを使用したTwitter埋め込み表示
- YouTube動画埋め込み
- 過去のお知らせ表示（展開可能）

**リファクタリングの成果**:
- UIコンポーネントの再利用により重複コード削減
- DataServiceを使用したデータ読み込み

#### pages/99_Song_List_beta.py（楽曲リストページ）

**責務**:
- 全楽曲リストの表示
- アーティスト順のソート表示

**主要機能**:
- DataServiceを使用したデータ読み込み
- UIコンポーネントを使用したテーブル表示

**リファクタリングの成果**:
- DataServiceによる統一的なデータ読み込み
- UIコンポーネントの再利用

#### src/ui/components.py（UIコンポーネント）

**責務**:
- 再利用可能なUIコンポーネントの提供
- UIロジックの分離

**提供するコンポーネント**:
- `render_search_form()`: 検索フォーム
- `render_results_table()`: 結果テーブル
- `render_pagination()`: ページネーション
- `render_twitter_embed()`: Twitter埋め込み

### 2. ビジネスロジック層

データ処理と検索機能を提供する層です。UIから独立しており、テストが容易です。

#### src/services/data_service.py（データサービス）

**責務**:
- TSVファイルからのデータ読み込み
- データの基本的な検証
- エラーハンドリング

**主要クラス**:
- `DataService`: データ読み込みと結合を担当

**主要メソッド**:
- `load_lives_data()`: 配信データ読み込み
- `load_songs_data()`: 楽曲データ読み込み
- `load_song_list_data()`: 楽曲リストデータ読み込み
- `merge_data()`: データ結合
- `get_last_error()`: エラーメッセージ取得

**エラーハンドリング**:
- ファイル不在時のDataLoadError
- データ処理エラー時のDataProcessingError
- エラーメッセージの保持と取得

#### src/services/search_service.py（検索サービス）

**責務**:
- キーワード検索
- フィルタリング
- 検索結果の管理

**主要クラス**:
- `SearchService`: 検索機能を担当

**主要メソッド**:
- `search()`: キーワード検索（複数フィールド対応）
- `filter_by_multiple_conditions()`: 複数条件フィルタリング

**検索機能**:
- 大文字小文字を区別しない検索
- 複数フィールド対応（曲名、アーティスト、ライブタイトル）
- 部分一致検索

#### src/core/data_pipeline.py（データパイプライン）

**責務**:
- データ処理の全体フロー管理
- 各処理ステップの実行
- キャッシング
- エラーハンドリング

**主要クラス**:
- `DataPipeline`: データ処理パイプラインを担当

**主要メソッド**:
- `execute()`: パイプライン全体を実行
- `_load_data()`: データ読み込みステップ
- `_merge_data()`: データ結合ステップ
- `_transform_data()`: データ変換ステップ
- `_sort_data()`: データソートステップ
- `_validate_step_result()`: ステップ結果検証
- `clear_cache()`: キャッシュクリア

**処理フロー**:
1. データ読み込み（DataServiceを使用）
2. データ結合（配信データと楽曲データ）
3. データ変換（タイムスタンプ、日付、URL、曲目番号）
4. データソート（配信日、LIVE_ID、タイムスタンプ）
5. 結果のキャッシュ

### 3. ユーティリティ層

汎用的な機能を提供する層です。

#### src/core/utils.py（ユーティリティ関数）

**責務**:
- タイムスタンプ変換
- URL生成
- 曲目番号生成
- 日付変換

**主要関数**:
- `convert_timestamp_to_seconds()`: タイムスタンプ文字列を秒数に変換
- `generate_youtube_url()`: YouTubeタイムスタンプ付きURL生成
- `generate_song_numbers()`: 曲目番号の自動生成
- `convert_date_string()`: 日付文字列の変換

**特徴**:
- 純粋関数として実装（副作用なし）
- 単一の責務を持つ
- テストが容易

#### src/config/settings.py（設定管理）

**責務**:
- アプリケーション設定の一元管理
- 環境変数からの設定読み込み
- デフォルト値の提供

**主要クラス**:
- `Config`: 設定を管理するデータクラス

**設定項目**:
- ファイルパス設定
- 表示設定（初期表示件数、追加表示件数）
- ページ設定（タイトル、アイコン、レイアウト）
- パフォーマンス設定（キャッシュ有効化、TTL）

**主要メソッド**:
- `from_env()`: 環境変数から設定読み込み
- `validate()`: 設定値の検証

#### src/config/logging_config.py（ロギング設定）

**責務**:
- ロギング設定の一元管理
- ログレベル、フォーマット、ファイル出力の制御
- ログファイルのローテーション

**主要関数**:
- `setup_logging()`: ロギング設定の初期化

**環境変数**:
- `SHINOUTA_LOG_LEVEL`: ログレベル（DEBUG、INFO、WARNING、ERROR）
- `SHINOUTA_ENABLE_FILE_LOGGING`: ファイルログ出力の有効化
- `SHINOUTA_LOG_FILE`: ログファイルパス

**ログローテーション**:
- 最大ファイルサイズ: 10MB
- 保持するバックアップ数: 5個

#### src/exceptions/errors.py（カスタム例外）

**責務**:
- カスタム例外の定義
- エラーログ機能

**主要クラス**:
- `ShinoutaTimeError`: 基底例外クラス
- `DataLoadError`: データ読み込みエラー
- `DataProcessingError`: データ処理エラー
- `ConfigurationError`: 設定エラー

**主要関数**:
- `log_error()`: エラーをログに記録

### 4. データ層

アプリケーションで使用するデータを格納する層です。

#### データファイル

- **M_YT_LIVE.TSV**: 配信情報（配信日、タイトル、URL）
- **M_YT_LIVE_TIMESTAMP.TSV**: 楽曲タイムスタンプ情報（曲名、アーティスト、タイムスタンプ）
- **V_SONG_LIST.TSV**: 楽曲リスト（アーティスト順）
- **tweet_embed_code.html**: Twitter埋め込みHTMLコード
- **tweet_height.txt**: Twitter埋め込み表示高さ設定

## 技術スタック

### フレームワーク・ライブラリ

| 技術 | バージョン | 用途 |
|------|-----------|------|
| **Streamlit** | - | Webアプリケーションフレームワーク |
| **Python** | 3.x | プログラミング言語 |
| **Pandas** | - | データ処理・分析 |

### データフォーマット

| フォーマット | 用途 |
|-------------|------|
| **TSV** | データストレージ（配信情報、楽曲情報） |
| **HTML** | Twitter埋め込みコード |
| **CSS** | スタイル定義 |

### 開発・実行環境

| 項目 | 内容 |
|------|------|
| **実行コマンド** | `streamlit run Home.py` |
| **依存関係管理** | `requirements.txt` |
| **インストール** | `pip install -r requirements.txt` |

## アーキテクチャの特徴

### 1. レイヤー化されたアーキテクチャ

- 明確な責務の分離
- 各レイヤーの独立性
- テスト可能性の向上

### 2. サービス指向設計

- DataService: データ読み込みと結合
- SearchService: 検索機能
- DataPipeline: データ処理フロー管理

### 3. 再利用可能なコンポーネント

- UIコンポーネントの共通化
- ユーティリティ関数の分離
- 設定管理の一元化

### 4. エラーハンドリングの統一

- カスタム例外クラス
- エラーログ機能
- グレースフルデグラデーション

### 5. ロギング機能

- 統一されたロギング設定
- 環境変数による制御
- ログファイルのローテーション

### 6. データキャッシング

```python
@st.cache_data
def load_data(path):
    """データ読み込みをキャッシュ"""
```

- Streamlitのキャッシュ機能を活用
- DataPipelineでの処理結果キャッシュ
- 不要な再読み込みを防止
- パフォーマンスの向上

### 7. 段階的表示

- 初期表示を25件に制限
- ユーザー操作で追加表示
- 大量データでも高速な初期表示

## パフォーマンス最適化

### 1. データキャッシング

- `@st.cache_data`デコレータの使用
- DataPipelineでの処理結果キャッシュ
- ファイル変更時のみ再読み込み
- メモリ効率の向上

### 2. 段階的表示

- 初期表示: 25件
- 追加表示: 25件ずつ
- DOM要素数の削減

### 3. 効率的なデータ処理

- Pandasの最適化された操作を使用
- 不要な列の早期削除
- 一度だけのソート実行

## セキュリティ考慮事項

### 1. XSS対策

- HTMLリンク生成は信頼できるデータソースのみ
- ユーザー入力は検索クエリのみ
- `unsafe_allow_html=True`の使用を最小限に

### 2. データの完全性

- TSVファイルは信頼できるソースから提供
- 手動管理によるデータ品質の担保

### 3. 外部リンク

- YouTube URLは公式ドメインのみ
- Twitter埋め込みは公式コードを使用

## 拡張性

### 将来的な拡張の可能性

1. **データベース化**
   - SQLiteやPostgreSQLへの移行
   - より高度なクエリ機能

2. **検索機能の強化**
   - 正規表現検索
   - 複数キーワード検索（AND/OR）
   - 日付範囲検索

3. **ユーザー機能**
   - お気に入り機能
   - プレイリスト作成
   - 視聴履歴

4. **管理機能**
   - データ追加・編集のWebインターフェース
   - YouTube API連携
   - 自動データ取得

5. **分析機能**
   - 歌唱頻度の統計
   - アーティスト別集計
   - 時系列分析

## リファクタリングの成果

### コード品質の向上

- **コード行数の削減**: Home.pyが約500行から約200行に削減
- **責務の明確化**: 各モジュールが単一の責務を持つ
- **重複コードの削減**: UIコンポーネントの再利用

### 保守性の向上

- **モジュール化**: 機能ごとに独立したモジュール
- **テスト可能性**: ビジネスロジックがUIから分離
- **エラーハンドリング**: 統一的なエラー処理

### 拡張性の向上

- **レイヤー化**: 各レイヤーが独立して拡張可能
- **設定管理**: 環境変数による柔軟な設定
- **ロギング**: 詳細なログによるデバッグ支援

## まとめ

「しのうたタイム」のリファクタリングにより、レイヤー化されたアーキテクチャを採用し、保守性、テスト可能性、拡張性が大幅に向上しました。各レイヤーが明確な責務を持ち、独立して動作することで、将来の機能追加や変更が容易になっています。

ファイルベースのデータストレージとモジュール化された設計により、メンテナンス性と拡張性を確保しつつ、ユーザーに快適な検索・閲覧体験を提供します。
